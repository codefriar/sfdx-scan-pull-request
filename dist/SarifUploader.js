var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as core from "@actions/core";
import { Octokit } from "@octokit/action";
import { context } from "@actions/github";
import { fileExists } from "./common.js";
import { spawn } from "node:child_process";
/**
 * @description This class is responsible for uploading the SARIF report to the GitHub code scanning API.
 */
export default class SarifUploader {
    constructor(scannerFlags) {
        this.sarifPath = scannerFlags.outfile;
        this.octokit = new Octokit();
    }
    /**
     * @description Uploads the SARIF report generated by other methods to the GitHub code scanning API.
     */
    uploadSarifFileToCodeQL() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            console.log("Uploading SARIF report ...");
            try {
                let base64Data = yield this.execShellCmds(this.sarifPath);
                const pullRequestNumber = (_a = context.payload.pull_request) === null || _a === void 0 ? void 0 : _a.number;
                const ref = `refs/pull/${pullRequestNumber}/head`;
                const toolName = "SfScaner";
                if (pullRequestNumber && fileExists(this.sarifPath)) {
                    yield this.octokit.codeScanning.uploadSarif({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        commit_sha: context.sha,
                        ref: ref,
                        sarif: base64Data,
                        tool_name: toolName,
                    });
                    core.info(`SARIF report uploaded successfully for pull request #${pullRequestNumber}`);
                }
                else {
                    core.warning("No pull request found. Skipping SARIF upload.");
                }
            }
            catch (error) {
                core.setFailed(`Failed to upload SARIF report: ${error.message}`);
            }
        });
    }
    /**
     * @description Executes the gzip and base64 commands to compress and encode the SARIF report.
     * @param sarifPath path to the SARIF report.
     */
    execShellCmds(sarifPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const gzipCommand = spawn("gzip", ["-c", sarifPath]);
                const base64Command = spawn("base64", ["-w0"]);
                gzipCommand.stdout.pipe(base64Command.stdin);
                let base64Output = "";
                base64Command.stdout.on("data", (data) => {
                    base64Output += data.toString();
                });
                base64Command.on("close", (code) => {
                    if (code === 0) {
                        resolve(base64Output);
                    }
                    else {
                        reject(new Error(`Command execution failed with code ${code}`));
                    }
                });
                gzipCommand.on("error", (error) => {
                    reject(error);
                });
                base64Command.on("error", (error) => {
                    reject(error);
                });
            });
        });
    }
}
//# sourceMappingURL=SarifUploader.js.map